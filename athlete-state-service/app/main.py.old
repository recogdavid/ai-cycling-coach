"""
AthleteState Service - FastAPI application
"""
from fastapi import FastAPI, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
import os
from typing import Dict, Any, Optional

from .models import AthleteState
from .managers import AthleteStateManager

# Initialize manager
manager = AthleteStateManager()

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Lifespan context manager for startup/shutdown events"""
    # Startup
    print("ðŸš€ Starting AthleteState Service")
    
    # Initialize connections
    await manager.initialize()
    
    yield
    
    # Shutdown
    print("ðŸ›‘ Shutting down AthleteState Service")
    await manager.cleanup()

# Create FastAPI app with lifespan
app = FastAPI(
    title="AthleteState Service",
    description="Manages athlete training state for AI Cycling Coach",
    version="0.1.0",
    lifespan=lifespan
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, restrict to your domains
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
async def root():
    """Root endpoint - service info"""
    return {
        "service": "AthleteState Service",
        "version": "0.1.0",
        "status": "running",
        "endpoints": {
            "health": "/health",
            "docs": "/docs",
            "get_state": "/api/v1/state/{athlete_id}",
            "update_state": "/api/v1/state/{athlete_id} (PATCH)",
            "log_event": "/api/v1/events (POST)"
        }
    }

@app.get("/health")
async def health_check():
    """Health check endpoint for Docker/load balancers"""
    # Check database connections
    db_ok = await manager.check_database_connection()
    redis_ok = await manager.check_redis_connection()
    
    if db_ok and redis_ok:
        return {"status": "healthy", "database": "connected", "redis": "connected"}
    else:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail=f"Service unhealthy: db={db_ok}, redis={redis_ok}"
        )

@app.get("/api/v1/state/{athlete_id}")
async def get_athlete_state(athlete_id: int):
    """Get current state for an athlete"""
    try:
        state = await manager.get_state(athlete_id)
        if state:
            return {
                "success": True,
                "athlete_id": athlete_id,
                "state": state.to_dict() if hasattr(state, 'to_dict') else state,
                "cached": manager.last_operation_cached
            }
        else:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Athlete {athlete_id} not found"
            )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error retrieving state: {str(e)}"
        )

@app.patch("/api/v1/state/{athlete_id}")
async def update_athlete_state(athlete_id: int, updates: Dict[str, Any]):
    """Update athlete state with partial updates"""
    try:
        success = await manager.update_state(athlete_id, updates)
        if success:
            return {
                "success": True,
                "athlete_id": athlete_id,
                "message": "State updated successfully",
                "updates_applied": list(updates.keys())
            }
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to update state"
            )
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error updating state: {str(e)}"
        )

@app.post("/api/v1/events")
async def log_coaching_event(
    athlete_id: int,
    event_type: str,
    trigger: Optional[str] = None,
    decision: Optional[str] = None,
    rationale: Optional[str] = None,
    metadata: Optional[Dict[str, Any]] = None
):
    """Log a coaching event/decision"""
    try:
        await manager.log_coaching_event(
            athlete_id=athlete_id,
            event_type=event_type,
            trigger=trigger,
            decision=decision,
            rationale=rationale,
            metadata=metadata or {}
        )
        return {
            "success": True,
            "message": "Event logged successfully",
            "event_type": event_type
        }
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error logging event: {str(e)}"
        )

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
